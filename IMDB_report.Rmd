---
title: "Análise  - Inteligência Computacional -  COC 361"
author: "Lucas Rolim e Anderson Barbosa"
date: "21 de outubro de 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
```

## Descrição do problema

**Problema: É possível prever a nota IMDB de um filme antes mesmo de ele ser lançado?**

Essa será a principal pergunta que irá guiar o desenvolvimento de uma análise de mais de 5000 filmes presentes no site do [IMDB](www.imdb.com). Utilizando técncias de aprendizado de máquina e estatística nós iremos não só tentar criar um modelo que seja capaz de responder à pergunta anterior de maneira satistatória como também iremos criar visualizações que nos permitam entender as relações entre essas variáveis.

Esse problema é importante não só para ajudar espectadores em geral a reduzir sua taxa de decepção ao ir ao cinema, mas também se caracteriza como de suma importância para a indústria cinematrográfica em si. Filmes, antes de tudo, são investimentos. Conseguir prever se um filme será um fiasco ou um sucesso de bilheteria pode poupar milhões as produtoras de filmes e investidores.

*Para os que desconhecem, o IMDB.com é a principal referência mundial na avaliação da qualidade de filmes. O site conta com dezenas de milhares de filmes e também com avaliações e críticas produzidas por centenas de milhares de usuários e críticos profissionais*


## Descrição dos dados

Os dados são originados de um processo de mineração dentro do site [IMDB.com](IMDB.com). Esse conjunto de dados possui informação de **5043 filmes**, lançados ao longo dos últimos 100 anos em 66 países. Ainda, conta com 2399 nomes de diretores e centenas de nomes de atores  atrizes.

**As 28 variáveis disponíveis são:**

| Variável                     	| Significado                                                                     	|
|------------------------------	|---------------------------------------------------------------------------------	|
| color                        	| ?                                                                               	|
| num_voted_users              	| Número de usuários que deram uma classificação ao filme no site do IMDB         	|
| cast_total_facebook_likes    	| Número total de curtidas de toda página do elenco no Facebook                   	|
| facenumber_in_poster         	| Número de faces humanas que aparecem  no poster do filme                        	|
| plot_keywords                	| Palavras-chave da trama                                                         	|
| movie_imdb_link              	| Endereço da página do filme no IMDB                                             	|
| num_user_for_reviews         	| Número de críticas de usuários do IMDB                                          	|
| language                     	| Idioma do filme                                                                 	|
| country                      	| País em que o filme foi produzido                                               	|
| content_rating               	| Avaliação do conteúdo                                                           	|
| budget                       	| Orçamento do filme                                                              	|
| title_year                   	| Ano de lançamento do filme                                                      	|
| imdb_score                   	| Nota do filme no IMDB                                                           	|
| aspect_ratio                 	| ?                                                                               	|
| movie_facebook_likes         	| Número de curtidas da página do filme no Facebook                               	|
| director_name                	| Nome do diretor do filme                                                        	|
| num_critic_for_reviews       	| Número de críticas externas ao IMDB                                             	|
| actor_(1,2,3)_name           	| Nomes dos três principais atores do filme                                       	|
| movie_title                  	| Título do filme                                                                 	|
| actor_(1,2,3)_facebook_likes 	| Números de curtidas das páginas dos três principais atores do filme no Facebook 	|
| director_facebook_likes      	| Número de curtidas da página do diretor no Facebook                             	|
| genres                       	| Gênero do filme                                                                 	|
| gross                        	| lucro bruto de bilheteria obtido pelo filme                                     	|
| duration                     	| Duração do filme em minutos                                                     	|

## Pré-processamento

O pré-processamento de dados é um passo importante no processo de mineração de dados. Os métodos de coleta de dados, em geral, não são controlados rigorosamente, o que resulta em um conjunto de dados com valores fora do intervalo, combinações impossíveis de dados, valores ausentes etc. Desta forma, o pré-processamento é necessário para evitar que a análise dos dados produza resultados enganosos. Ele envolve limpeza de dados, normalização, transformação de variáveis, entre outros. O resultado final do pré-processamento de dados é o conjunto de treinamento final, que será utilizado para o ajuste do modelo.

### Leitura dos Dados

```{r leitura}
imdb_data = read.csv("movie_metadata.csv",stringsAsFactors = FALSE)
str(imdb_data)
```
### Normalização dos Dados

Algumas das variáveis de texto do conjunto de dados serão convertidas em variáveis numéricas através de um critério de normalização definido pelas seguintes regras:

- Se o filme foi produzido no EUA a variável **country** será 1, caso contrário será 0;
- Se o filme foi produzido em inglês a variável **language** será 1, caso contrário será 0.
- Todos os filmes terão a variável **director_name** substituída pela média da nota IMDB dos filmes já feitos pelo diretor no passado.

Essas regras de normalização foram definidas pensando no fato da indústria cinematográfica americana ser a mais
bem desenvolvida e com maiores orçamentos do mundo, além de produzir os maiores sucessos das últimas décadas. Logo, espera-se que filmes americanos tenham uma probabilidade maior de pontuar melhor na escala IMDB.

Por fim, passaremos a considerar apenas os valores numéricos do modelo e também desconsideraremos as entradas com valores ausentes.

*A normalização da variável director_name será feita apenas no após o particionamento do conjunto de dados (próximo bloco de código). Esse cuidado é necessário para que não sejam levados em conta no cálculo da média do IMDB do diretor os filmes que estão no conjunto de testes*

```{r normalization }
library(dplyr)

imdb_data = na.exclude(imdb_data)
imdb_data$language[imdb_data$language !="English"] = 0
imdb_data$language[imdb_data$language =="English"] = 1
imdb_data$language <- as.numeric(imdb_data$language)
imdb_data$country[imdb_data$country != "USA"] = 0
imdb_data$country[imdb_data$country == "USA"] = 1
imdb_data$country <- as.numeric(imdb_data$country)

```
### Particionamento dos conjunto de dados

Utilizaremos dois conjuntos de dados ao longo das análises, um para treino e um para testes. Essa estratégia visa evitar *(ou ao menos identificar)* o problema de overfitting do modelo no conjunto de treino.

A proporção da separação foi de 70% dos dados para treino e 30% para testes. Essas proporção foi retirada da literatura.

```{r split}
library(caTools)
set.seed(161095)
split = sample.split(imdb_data$imdb_score,SplitRatio = 0.7)
trainData = subset(imdb_data,split == TRUE)
testData = subset(imdb_data,split == FALSE)

# Trecho de normalização do director_name
directorMean <-function(data){
  data = directorHistory [which(directorHistory ==data),2]
  data
}
directorHistory = summarise(group_by(trainData,director_name),mean=mean(imdb_score))
directorIMDB = sapply(trainData$director_name,directorMean)
trainData$director_name <- as.numeric(directorIMDB)
directorIMDB = sapply(testData$director_name,directorMean)
testData$director_name <- as.numeric(directorIMDB)
# fim da normalização do director_name

trainData<- trainData[sapply(trainData,is.numeric)]
testData <- testData[sapply(testData ,is.numeric)]
trainData <- na.exclude(trainData)
testData <- na.exclude(testData)
```

### Definição das Variáveis

Nesse trecho iremos definir de maneira genérica as variáveis que serão utilizadas daqui em diante. Esse processo poupa o trabalho de reescrever código depois e também facilita a manutenção do mesmo.

```{r variáveis}
goal_variable = "imdb_score"
dependent_variable = paste(goal_variable," ~ ")
independent_variables = paste(colnames(trainData)[colnames(trainData) != goal_variable],collapse = "+")
model_variables = paste(dependent_variable,independent_variables)
```
## Visualização geral do Conjunto de Dados

### Matriz de Correlação

``` {r matriz de correlação}
library(corrplot)
corrplot(cor(trainData))
```

**FAZER: COMENTAR SOBRE MATRIZ DE CORRELAÇÃO**


### Histograma


```{r Histograma}
library(ggplot2)
ggplot(imdb_data,aes(x=imdb_score)) + geom_histogram() + xlab("Nota no IMDB") + ylab("Número de Filmes")
```



A partir do histograma acima, é possível observar que a variável imdb_score segue uma distribuição normal com média aproximadamente igual 6,5. O valor que se esperava para essa média seria algo em torno de 5,0, uma vez que as notas variam de 0 a 10. Uma possível explicação para a média ter sido diferente da esperada é que o número de registros não é grande o suficiente ou que muito poucos filmes tendem a ser classificados com a nota menor que 2.


### Relação entre a nota IMDB e a duração do filme


```{r IMDBvsDuração}

ggplot(imdb_data,aes(x=duration, y=imdb_score)) + geom_point(colour="grey60") +
  stat_smooth(method=lm, se=FALSE, colour="black") + ylab("Nota no IMDB") + xlab("Duração do filme (minutos)")
```



Este scatterplot mostra que a duração do filme e sua nota no IMDB apresentam uma fraca correlação positiva.

### Relação entre a nota IMDB e o lucro

```{r IMDBvsLucro}
ggplot(imdb_data,aes(x=gross, y=imdb_score)) + geom_point(colour="grey60") +
  stat_smooth(method=lm, se=FALSE, colour="black") + ylab("Nota no IMDB") + xlab("Lucro do Filme")
```

Este scatterplot, assim como o anterior, mostra que o lucro obtido pelo filme e sua nota no IMDB apresentam uma fraca correlação positiva.

### Relação entre a nota IMDB e orçamento

```{r IMDBvsOrçamento}
ggplot(imdb_data,aes(x=budget, y=imdb_score)) + geom_point(colour="grey60") +
  stat_smooth(method=lm, se=FALSE, colour="black") + ylab("Nota no IMDB") + xlab("Orçamento do Filme")
```

Este scatterplot mostra que o orçamento do filme e sua nota no IMDB não estão correlacionadas.

### Relação entre a nota IMDB e o Diretor

```{r IMDBvsDiretor}
ggplot(trainData,aes(x=director_name, y=imdb_score)) + geom_point(colour="grey60") +
  stat_smooth(method=lm, se=FALSE, colour="black") + ylab("Nota no IMDB") + xlab("Diretor do Filme")
```

Este scatterplot mostra que o diretor do filme e sua nota no IMDB apresentam forte correlação positiva.

## Metodologia

A estratégia adotada será partir do modelo mais simples e rápido para o modelo mais complexo e robusto. Visto isso, em nossa análise testaremos os quatro seguintes modelos:

- Modelo "Burro", ou previsão pela média;
- Modelo de Regressão Linear;
- Modelo da Árvore de Regressão;
- Modelo de Florestas Aleatórias.

Além disso, para facilitar a avaliação dos modelos, adotaremos um indicador numérico unitário de erro. O indicador escolhido será o **RMSE**. O RMSE *(root-mean-square error)* representa o desvio padrão das diferenças entre os valores estimados e os valores esperados e é calculado como a raiz quadrada do SSE *(sum of squared errors of prediction* dividido pelo número de registros.

### Modelo "Burro"

O modelo "Burro" consiste em estimar os valores de uma variável através da média dos valores observados dessa mesma variável.

```{r ModeloMédia}
DumbPredict = mean(trainData$imdb_score)
SSE = sum((testData$imdb_score - DumbPredict)^2)
RMSE = sqrt(SSE / nrow(testData))
RMSE
```

Este é um resultado RMSE muito ruim, o que já era esperado, pois, como o nome indica, este modelo não é adequado para fazer estimativas na maior parte dos casos em que não se tem um volume extremamente grande de dados.

## Modelo de Regressão Linear

O modelo de Regressão Linear consiste em estimar uma variável *(chamada de variável dependente)* a partir de outra variável *(chamada de variável independente)* estimando os parâmetros da relação linear entre elas.

Uma relação linear é do tipo: y(t) = ax(t) + b, onde y(t) é a variável dependente e x(t) é a variável independente.

```{r ModeloLinear, echo=FALSE}
linearModel = lm(model_variables,data=trainData)
summary(linearModel)

linerPrediction = predict(linearModel,testData)
SSE = sum((testData$imdb_score - linerPrediction)^2)
RMSE = sqrt(SSE / nrow(testData))
RMSE
```

Como esperado, o modelo de Regressão Linear obteve um resultado melhor que o modelo de previsão pela média, porém ainda não apresenta um bom resultado. Muito disso porque, como vimos em diversas plotagens anteriormente, a maior parte das variáveis não segue uma relação linear.


## Modelo da Árvore de Regressão

O modelo da Árvore de Regressão consiste em criar uma árvore de decisão cujo resultado é um número que representa o valor estimado da variável. Os nós de decisão da árvore de regressão são formados por outras variáveis do conjunto de dados que são selecionadas pelo algoritmo.

``` {r modeloArvoreDeRegressao}
library(rpart)

set.seed(3)
m.rpart <- rpart(imdb_score~.,data=trainData)
m.rpart
```

```{r plotArvoreR}
library(rpart.plot)
rpart.plot(m.rpart)
```

**FAZER: EXPLICAR NÓS DE DECISÃO E HISTOGRAMAS. ALÉM DISSO, DAR NOME AOS TRECHOS DE CÓDIGO**

```{r}
p.rpart <- predict(m.rpart,testData)
tree_dataframe <- data.frame(p.rpart,testData$imdb_score)
ggplot(tree_dataframe, aes(x=p.rpart)) + geom_histogram(fill="white", colour="black")

```

```{r}
ggplot(tree_dataframe, aes(x=testData$imdb_score)) + geom_histogram(fill="white", colour="black")
```

```{r}
cor(p.rpart,testData$imdb_score)
```


```{r}
RMSE=sqrt(mean((p.rpart-testData$imdb_score)^2))
RMSE
```

Diferentemente do que era esperado, o modelo de árvore de regressão obteve um resultado pior do que o modelo de regressão linear, que é mais simples. Uma possível causa deste resultado é a substituição dos valores da variável *director_name*.


## Modelo de Florestas Aleatórias

O modelo de florestas aleatórias cria um determinado número de árvores nas quais ele distribui os parâmetros aleatóriamente. Em geral, de todas essas árvores geradas aleatóriamente, aquela que obtem o melhor resultado é melhor do que a árvore criada pelo algoritmo no modelo de árvore de regressão simples. Nesta análise, foram criadas florestas aleatórias com diferentes números de árvores para obter aquele que gera o melhor resultado.


```{r ModeloFlorestaaleatória}
library(randomForest)
array_ntree<- c(100,200,300,400,500,600,700)
RMSE_vector <- c()
for(i in array_ntree){
  set.seed(1995)
  stevenForest = randomForest(imdb_score  ~.,data=trainData,ntree = i)
  predictForest = predict(stevenForest,newdata= testData)
  SSE = sum((testData$imdb_score - predictForest)^2)
  RMSE = sqrt(SSE / nrow(testData))
  RMSE_vector <- c(RMSE_vector,RMSE)
}
min(RMSE_vector)

```

**Desempenho do modelo de acordo com o número de árvores utilizadas**

```{r desempenhoVsArvores}
ggplot(data.frame(array_ntree,RMSE_vector), aes(x=(array_ntree), y=RMSE_vector)) + geom_line() + geom_point()
```

Como esperado, o modelo de florestas aleatórias, por ser o modelo mais complexo e robusto, obteve um excelente resultado, sendo melhor do que todos os testados anteriormente.


**Conclusões Modelo Floresta Aleatória**


*Pacotes utilizados nessa análise*

- rMarkdown
- ggplot2
- caTools
- randomForest
- dplyr
- rpart
- rpart.plot
- corrplot
